[{"body":"MARK is a simple domain specific language (DSL) that can be written in any text editor. We however recommend using the MARK Eclipse plugin which brings syntax highlighting, auto-completion, and some other benefits that will support you in writing MARK rules.\nInstall the MARK Eclipse Plugin  In Eclipse, click on Help-\u0026gt;Install New Software... Add the update site: https://codyze.s3.eu-central-1.amazonaws.com/codyze-mark-eclipse-plugin/ Install   Start writing MARK policies  Create a new project by clicking on File-\u0026gt;New-\u0026gt;Project. The project type does not matter. Create a new file with the extension .mark Confirm the dialog to configure Xtext for your project. Start writing entities  and rules .  You may include all entities and rules in a single MARK file or organize them in multiple files as you with. As long as all MARK files are located in the same folder, Codyze will load entities and rules from all files in that folder.\n","excerpt":"MARK is a simple domain specific language (DSL) that can be written in any text editor. We however …","ref":"https://www.codyze.io/docs/mark-authors/installation/","title":"Install MARK IDE"},{"body":"Prerequisites  Java (OpenJDK) 11 or later  Check out, build, and extend Codyze  Fork the Codyze repo on GitHub and clone it, including submodules:\ngit clone --recurse-submodules git://github.com/\u0026lt;YOUR GITHUB\u0026gt;/codyze Create a branch for your contribution. We recommend prefixing the branch name with fix- if you are providing a bug fix or feature- if you plan to add a feature:\ngit checkout -b feature-MY_EPIC_FEATURE Make your changes and make sure that the project builds without errors, passes all tests, and is properly formatted:\n./gradlew clean spotlessApply build publishToMavenLocal installDist\nThe purpose of these gradle tasks is as follows:  clean Removes previous build artifacts spotlessApply Applies source code formatting with the settings in formatter-settings.xml. If the code is not properly formatted the build server will reject it. build Builds the main artifact (the jar file containing Codyze) publishToMavenLocal (optional) publishes the build artifact to your local Maven repository so it is available as a dependency for other projects installDist Create an executable script for Linux, Mac, and Windows in build/install/codyze/bin   When everything works, git commit your changes and git push them to Github, then create a pull request (PR). Make sure to describe want you intend the code to do and refer to any issues your PR might address (using the notation #123) If you\u0026rsquo;re not yet ready for a review, add \u0026ldquo;WIP\u0026rdquo; to the PR name to indicate it\u0026rsquo;s a work in progress. Wait for the automated CI workflow to do some checks. Continue working on your PR by pushing further commits to your branch until you are satisfied When you\u0026rsquo;re ready for a review, add a comment to the PR, and remove any \u0026ldquo;WIP\u0026rdquo; markers.  Code formatting Codyze uses the gradle spotless plugin to format source code. You may import the code style definitions into your favorite IDE to apply it immediately.\nGradle  Simply run ./gradlew spotlessApply  IntelliJ  In IntelliJ, open Settings-\u0026gt;Editor-\u0026gt;Code Style-\u0026gt;Java and click on the cog icon. Choose Import Scheme-\u0026gt;Eclipse XML Profile and select the file formatter-settings.xml in the project\u0026rsquo;s root folder.  Eclipse  In Eclipse, open Window-\u0026gt;Preferences-\u0026gt;Java-\u0026gt;Code Style-\u0026gt;Formatter Click Import and select the file formatter-settings.xml in the project\u0026rsquo;s root folder.  ","excerpt":"Prerequisites  Java (OpenJDK) 11 or later  Check out, build, and extend Codyze  Fork the Codyze repo …","ref":"https://www.codyze.io/docs/contributors/code/","title":"Build the project"},{"body":"Prerequisites  Java 11 or higher  Pre-built Release  Download a zipped release of Codyze from our GitHub release page  Unzip the file Execute Codyze using bin\\codyze.bat (Windows) or bin/codyze (Mac, Linux)  Docker We\u0026rsquo;re also offering Codyze as a container image. You can find an image with the latest release in the project\u0026rsquo;s container registry .\nBuild from Source  Clone the source code for Codyze from the project\u0026rsquo;s GitHub repository . To build an executable version of Codyze, run ./gradlew installDist The executable Codyze installation is located under build/install/codyze  ","excerpt":"Prerequisites  Java 11 or higher  Pre-built Release  Download a zipped release of Codyze from our …","ref":"https://www.codyze.io/docs/getting-started/installation/","title":"Install Codyze"},{"body":"Codyze can be configured through command line options when starting codyze.\nThe most important options are\n the execution modes (-c. -l and -t) the source path (-s \u0026lt;sourcepath\u0026gt;) the path to the MARK files (-m \u0026lt;markpath\u0026gt;)  Another way for configuring Codyze is through a YAML configuration file. Use --config to specify the path to the file.\nFor more information about the configuration file and a complete list of all configurations, please refer to our wiki page\n","excerpt":"Codyze can be configured through command line options when starting codyze.\nThe most important …","ref":"https://www.codyze.io/docs/getting-started/configuration/","title":"Configuration"},{"body":"","excerpt":"","ref":"https://www.codyze.io/docs/getting-started/","title":"Get Started"},{"body":"Command line mode When running in command line interface (CLI) mode, Codyze can be used to automatically check a code base against a set of MARK rules. A short exemplary call to start codyze in command line interface mode would be\n$ ./bin/codyze -c -s \u0026lt;sourcepath\u0026gt; -m ./mark -o \u0026lt;outputpath\u0026gt; -c enters command line mode. It will parse all files given by the -s argument, analyze them against the MARK policies given by -m, and write the findings in JSON format to the file given by -o. If - is given as the output name, the results will be dumped to stdout.\nNote that line numbers of findings in JSON output start by 0.\nCI/CD Integration The CLI mode is a perfect candidate for integration in CI/CD processes, such as GitHub Actions. The following file can be used as an example so set up a compliance check for Java-based applications using GitHub Actions:\nname:buildon:- pushenv:CODYZE_VERSION:\u0026#34;2.0.0\u0026#34;jobs:build:runs-on:ubuntu-lateststeps:- uses:actions/checkout@v3- uses:actions/setup-java@v3with:distribution:\u0026#34;zulu\u0026#34;java-version:\u0026#34;11\u0026#34;- name:Install codyzerun:|wget \u0026#34;https://github.com/Fraunhofer-AISEC/codyze/releases/download/v${CODYZE_VERSION}/codyze-${CODYZE_VERSION}.zip\u0026#34; \u0026amp;\u0026amp; unzip codyze-${CODYZE_VERSION}.zip- name:Check compliancerun:|codyze-${CODYZE_VERSION}/bin/codyze -c -o - -m codyze-${CODYZE_VERSION}/mark -s src/main/java","excerpt":"Command line mode When running in command line interface (CLI) mode, Codyze can be used to …","ref":"https://www.codyze.io/docs/getting-started/cli/","title":"Using CLI mode"},{"body":"MARK rules refer to entities - abstract objects that wrap the real object classes of the analyzed programming language (in case of object oriented languages) and group methods with similar semantics in so-called ops. A MARK entity defines three parts:\n A name A set of ops (operations) A set of MARK variables  Writing MARK rules for a library requires a good understanding of the library API and its class hierarchy. We recommend the following approach to writing MARK entities.\n Model relevant classes as MARK entities Define ops and variables (Optionally) blacklist some ops  Model relevant classes as MARK entities It is certainly not necessary to model all classes of the software library as MARK entities. Rather, you need to identify those classes which hold relevant data or provide functions. Although in many cases, several classes of the programming language can be summarized in one abstract MARK entity, it might be easier to directly map classes to entities in the first iteration.\nThe name of an entity can be freely chosen. If it refers to a specific class in the programming language, though, it might make sense to name them accordingly.\nDefine Ops and variables The next step is to define ops. An op is a group of semantically equal or similar functions, methods, or constructors, given as fully qualified signatures. Especially overloaded functions with the same name but different parameters are candidates for being grouped in an op. For cryptographic libraries, typical ops are:\n instantiate - a group of functions for instantiating a class or creating an object of a class initialize - a group of functions that initialize a cryptographic algorithms, e.g. by setting a key or initialization vector update - a group of functions that process further data by a cryptographic algorithm finalize- a group of functions that terminate a cryptographic algorithm reset- a group of functions that reset a cryptographic algorithm and make it ready for further processing.  The name of an op can be freely chosen. When specifying fully qualified function or method signatures in an op, parameters are typed and can be unnamed or named. Unnamed parameters are indicated by the name \u0026ldquo;_\u0026rdquo; and do not play any role in the definition of rules. Named parameters refer to MARK variables and can be used when writing rules. We recommend to name only those parameters which are required in rules, as named parameters will increase the memory cost and runtime of the analysis.\nExample: The following op instantiate refers to only a single Java method, called de.example.Crypto.getInstance. Neither the return type, nor modifiers such as public, static, final etc. are given in MARK. The method signature contains one named parameter of type java.lang.String and one unnamed parameter without type restriction. Note that the name of the parameter does not relate to the parameter name in the programming language, but rather to a MARK variable.\n op instantiate { de.example.Crypto.getInstance( algorithm : java.lang.String, // Named typed parameter _ // Unnamed untyped parameter ); }  So, this MARK op would include the following methods of a class de.example.Crypto:\n public static Crypto getInstance(String x, String y) private void getInstance(String x, byte y)  It would however not include a method void getInstance(String x) (wrong number of parameters) or getInstance(byte x, String y) (wrong type of 1st parameter).\nTo make use of named parameters, they must additionally be declared as entity variables using the var keyword:\n entity Crypto { var algorithm; // this makes parameter \"algorithm\" available when writing rules. op instantiate { de.example.Crypto.getInstance( algorithm : java.lang.String, // Named typed parameter _ // Unnamed untyped parameter ); } }  (Optionally) blacklist some Ops In some cases, groups of functions or methods should not be used at all by a program. This applies e.g. to deprecated functions or functions that are known to be insecure. MARK provides a shortcut to mark any use of such functions as insecure: the forbidden keyword.\n entity Crypto { op instantiate { de.example.Crypto.getInstance( algorithm : java.lang.String, // Named typed parameter _ // Unnamed untyped parameter ); forbidden de.example.Crypto.getInstanceDeprecated(); // Any use of this function will be flagged } }  Any occurrence of getInstanceDeprecated() in the program will be marked as insecure, without further evaluation of rules. This is not only a shortcut, removing the need to write separate rules, but also a way to cut down analysis time, as Codyze does not need to find instances of the entity, but will rather indicate the error immediately when it sees a usage of the method.\nComplete Example  entity org.bouncycastle.crypto.digests.SHA512Digest isa org.bouncycastle.crypto.Digest { var instance : org.bouncycastle.crypto.digests.SHA512Digest; // Alternative for `this` var encodedState : byte[]; var copy : org.bouncycastle.crypto.digests.SHA512Digest; var inByte : byte; var inByteArray : byte[]; var inByteArrayOff : int; var inByteArraylen : int; var outArray : byte[]; var outArrayOff : int; var resultLen : int; op instantiate { this = org.bouncycastle.crypto.digests.SHA512Digest(); this = org.bouncycastle.crypto.digests.SHA512Digest(encodedState); instance = org.bouncycastle.crypto.digests.SHA512Digest(copy); } op update { org.bouncycastle.crypto.digests.SHA512Digest.update(inByte); org.bouncycastle.crypto.digests.SHA512Digest.update(inByteArray, inByteArrayOff, inByteArrayLen); } op finish { org.bouncycastle.crypto.digests.SHA512Digest.finish(); } op finalize { resultLen = org.bouncycastle.crypto.digests.SHA512Digest.doFinal(outArray, outArrayOff); } op reset { org.bouncycastle.crypto.digests.SHA512Digest.reset(); org.bouncycastle.crypto.digests.SHA512Digest.reset(_); } }   ","excerpt":"MARK rules refer to entities - abstract objects that wrap the real object classes of the analyzed …","ref":"https://www.codyze.io/docs/mark-authors/define-entities/","title":"MARK Entities"},{"body":"Codyze can be integrated into multiple IDEs to automatically scan your code for errors.\nIntegration in Eclipse The Codyze plugin can be installed from an Eclipse update site. It has been tested against Eclipse 2019-12 and later.\n In Eclipse, click on Help-\u0026gt;Install New Software... Click Add... to add a new update site Choose a name and enter the location https://codyze.s3.eu-central-1.amazonaws.com/codyze-eclipse-plugin/ (note that this is an Eclipse update site URL and not suited to open with a web browser)  Choose and install Codyze Code Analyzer  Once installed, configure the Eclipse plugin to use the local LSP server:\n Go to Windows-\u0026gt;Preferences-\u0026gt;Codyze Code Analysis and configure the path to the analysis server binary  If the configuration is correct, .java and .cpp files will be automatically scanned when they are saved. Any errors found by Codyze will be highlighted as problems. If Codyze verifies that an API is correctly used, it will mark the line with a hint.  Integration in IntelliJ  Download and install the LSP Support plugin. Restart IntelliJ. Go to Settings -\u0026gt; Language Server Protocol -\u0026gt; Server Definitions Add a new server definition of type Executable for extension java and navigate to your local codyze-\u0026lt;version\u0026gt;/bin/codyze script.  If everything works as intended, you should see a green circle in your IntelliJ status bar, indicating that the connection to the language server was successful.\nIntegration in Visual Studio 2019 The Codyze plugin can be installed from the Visual Studio 2019 Marketplace\nIf you prefer installing the plugin from the release page, proceed as follows:\n Download the zipped extension from the release page Unzip the file Double-click the VSIX-file to install the extension Launch Visual Studio  On startup, the plugin will ask you for the path to Codyze and to the mark files you want to use. If everythings checks out, the plugin will automatically start an instance of Codyze when a solution is opened. It will then scan .cpp files when opened or saved and highlight potential problems.\nTo adjust the path to Codyze, the mark files or change the command line arguments used for Codyze, in Visual Studio go to Tools -\u0026gt; Options... -\u0026gt; Codyze Plugin -\u0026gt; Codyze Settings.\nIntegration in Visual Studio Code We build a Visual Studio Code plugin of Codyze for every new version. You can download a bundled *.vsix plugin from the release page of Codyze .\nIntegration through LSP mode Codyze offers an LSP mode. You can user the LSP mode to integrate Codyze into any IDE or text editor with support for LSP. You need to look up the recommended approach for your favorite IDE or text editor.\nOnce you know, how to configure an LSP tool, you need to start Codyze in LSP mode, i.e. codyze -l. Please refer to the configuration page.\n","excerpt":"Codyze can be integrated into multiple IDEs to automatically scan your code for errors.\nIntegration …","ref":"https://www.codyze.io/docs/getting-started/lsp/","title":"Using plugins"},{"body":"Once the core functions of a library have been modeled as MARK entities, you can start writing rules. MARK rules operate over instances of entities and define conditions which must apply to these instances. A MARK \u0026ldquo;instance\u0026rdquo; may correspond to an actual object in the program, but in the case of non-object oriented languages or static methods, it may simply be an abstract set of function calls and variables.\nBasic rule structure MARK rules are structured as follows:\n rule MyRule { using // instances go here ensure // conditions go here onfail // error message goes here }  Each rule has a name which must be unique across along all MARK files loaded into Codyze. The using keyword starts the declaration of instances of MARK entities and the ensure keyword starts the actual condition. If Codyze finds a violation of the condition in the program, it will issue a finding with the message indicated by the onfail identifier.\nTo illustrate the process of writing MARK rules, let us assume we want to ensure that the MARK entity Crypto from the previous section uses either of the two cryptographic algorithms Algo1 or Algo2 and that the algorithm is initiated with a parameter which is longer than 16 bytes.\n rule ID_2 { using Crypto as c, // instance c of MARK entity Crypto CryptoParameter as cp // instance cp of MARK entity CryptoParameter ensure _is(c.param, cp) // variable c.param == cp \u0026\u0026 _length(cp.rawData) = 16 // byte length of cp.rawData = 16 onfail // todo }  Preconditions Some rules only apply if certain preconditions are fulfilled, i.e. such preconditions will be evaluated before the actual condition. If they fail, the main condition will not be evaluated and the rule will not return any result (i.e. it will neither confirm a valid program nor flag a wrong program). Preconditions follow the same syntax as the main condition, but are declared by the when keyword.\n rule ID_2 { using Crypto as c, // instance c of MARK entity Crypto CryptoParameter as cp // instance cp of MARK entity CryptoParameter when c.algorithm == \"Algo1\" // rule is only relevant for \"Algo1\" ensure _is(c.param, cp) // variable c.param == cp \u0026\u0026 _length(cp.rawData) = 16 // byte length of cp.rawData = 16 onfail // todo }  Built-in Predicates MARK comes with a number of built in functions that can be used as predicates in conditions and preconditions. These built-ins are called when MARK rules are evaluated and operate over their input arguments (typically MARK objects or constants) and the current evaluation context. By convention, built-ins should start with an underscore (_). When a built-in fails, it will return an Error object that always evaluates to not applicable, i.e. neither true nor false.\n_between Function: _between(String str, String start, String end)\nExample:\n ensure _between(\u0026#34;\u0026lt;09\u0026gt;\u0026#34;, \u0026#34;\u0026lt;\u0026#34;, \u0026#34;\u0026gt;\u0026#34;) == \u0026#34;09\u0026#34; Returns the part of the string between start and end which both have to be part of the string. If start or end are not part of the string, this returns an Error.\n_direct_eog_connection Function: _direct_eog_connection(Node n1, Node n2)\nExample:\n ensure _direct_eog_connection(n1, n2) Checks if there is a direct EOG-connection (i.e., without branches) between the two given vertices.\n_eog_connection Function: _eog_connection(Node n1, Node n2)\nExample:\n ensure _eog_connection(n1, n2) Checks if there is an arbitrary EOG-connection between the two given vertices.\n_get_code Function: _get_code(a)\nExample: TODO\nReturns the corresponding source code of MARK object a. If this is not possible, this returns an Error.\n_has_value Function: __has_value(a,b)\nExample:\n ensure __has_value(a, b) Returns true if MARK object a may be assigned value b (e.g., a constant).\n_inside_same_function Function: __inside_same_function(a,b)\nExample:\n ensure __inside_same_function(a, b) Returns true if MARK objects a and b reside in the same function.\n_is Function: _is(a,b)\nExample:\n ensure _is(a, b) Returns true if MARK object a is equal to variable b.\n_is_instance Function: _is_instance(a, String classname)\nExample:\n ensure _is_instance(a, \u0026#34;java.lang.String\u0026#34;) Returns true if MARK object a is an instance of classname. classname has to be the fully qualified name of the class.\n_length Function: _length(a)\nExample:\n ensure _length(a) == 5 // e.g. for array declaration `new int[5]` Returns the length of MARK object a. Currently, this can only return the dimension of an Java array.\n_now Function: _now()\nExample:\n ensure _now() == 1653955200 // 2022-05-31T00:00:00Z Returns the current time as the number of seconds since epoch (1970-01-01T00:00:00Z). Relies on Java\u0026rsquo;s Instant.now().\n_receives_value_from Function: _receives_value_from(a,b)\nExample:\n ensure _receives_value_from(a, b) Returns true, if there is a data flow from a to b.\n_split Function: _split(String str, String splitter, int position)\nExample:\n ensure _split(\u0026#34;ASD/EFG/JKL\u0026#34;, \u0026#34;/\u0026#34;, 1) == \u0026#34;EFG\u0026#34; Behaves like the Java expression String.split(String splitter)[position]. That is, it splits the string str at all occurrences of splitter and returns the positionth substring. Returns an Error if no such occurrence is found.\n_split_disjoint Function: _split_disjoint(String str, String splitter, List set)\nExample:\n ensure _split_disjoint(\u0026#34;ASD/EFG/JKL\u0026#34;, \u0026#34;/\u0026#34;, [\u0026#34;ABC\u0026#34;, \u0026#34;EFG\u0026#34;, \u0026#34;JKL\u0026#34;]) Splits str at all occurrences of splitter and checks, if any of the resulting elements is part of the provided set. Returns an Error if no occurrence of split is found.\n_split_match_unordered Function: _split_match_unordered(String str, String splitter, List set, Boolean strict)\nExample:\n ensure _split_match_unordered(\u0026#34;ASD/EFG/JKL\u0026#34;, \u0026#34;/\u0026#34;, [\u0026#34;ASD\u0026#34;, \u0026#34;EFG\u0026#34;, \u0026#34;JKL\u0026#34;], true) Splits str at all occurrences of splitter and checks, if resulting elements are part of the provided set. The optional parameter strict controls if the set resulting from splitting should be identical to the provided set. Returns an Error if no occurrence of split is found.\n_starts_with Function: _starts_with(String str, String start)\nExample:\n ensure _starts_with(\u0026#34;ASDEFGJKL\u0026#34;, \u0026#34;ASD\u0026#34;) Returns true if str starts with start.\n_year Function: _year(Int time)\nExample:\n ensure _year(1653955200) == 2022 // 2022-05-31T00:00:00Z Returns the year in which time is in. time represents the number of seconds since epoch (1970-01-01T00:00:00Z).\n","excerpt":"Once the core functions of a library have been modeled as MARK entities, you can start writing …","ref":"https://www.codyze.io/docs/mark-authors/mark-authors/","title":"MARK Rules"},{"body":"Codyze parses source code and checks it for compliance with predefined policies. These policies are written in a domain specific language called MARK and describe the correct and expected use of, for example security-critical, APIs.\nMARK policies are separated into Entities and Rules.\n Entities describe and group API functions at an abstract level and declare MARK variables that refer to function arguments or return values. Rules describe the expected usage of these entities. A violation of a rule will result in a Finding and is shown as a warning or error in the developer\u0026rsquo;s IDE.  When modeling a library, you will typically start by describing its classes or functions as MARK entitites and then write rules.\nCodyze comes with a set of MARK policies for the Botan (C++), Bouncycastle (Java) and Jackson (Java) libraries, but MARK policies for other libraries can be added anytime.\nMARK policies are simple text files and can be created with any text editor, but we recommend installing the Eclipse plugin  which comes with syntax highlighting and code completion for MARK files.\n","excerpt":"Codyze parses source code and checks it for compliance with predefined policies. These policies are …","ref":"https://www.codyze.io/docs/mark-authors/","title":"Write MARK Policies"},{"body":" Codyze is open source and an ongoing effort to support developers and auditors in improving the quality of security-critical code. We welcome everybody to contribute to this project, be it fixing a typo in the documentation or implementing whole new language support and analysis modules.\nPlease note that parts of this Codyze are backed by research projects. If you plan to make larger contributions, please contact us upfront to align your plans with possibly ongoing projects.\n Contributing to this documentation This documentation lives in the same repository as the code and the idea is that both are always consistent. If you make changes in the code that affect the documentation, please update the documentation in the same pull request.\nTo extend or fix errors in this documentation, proceed as follows:\n Fork the Codyze repo on GitHub. Make your changes and send a pull request (PR). If you\u0026rsquo;re not yet ready for a review, add \u0026ldquo;WIP\u0026rdquo; to the PR name to indicate it\u0026rsquo;s a work in progress. (Don\u0026rsquo;t add the Hugo property \u0026ldquo;draft = true\u0026rdquo; to the page front matter, because that prevents the auto-deployment of the content preview described in the next point.) Wait for the automated PR workflow to do some checks. When it\u0026rsquo;s ready, you should see a comment like this: deploy/netlify — Deploy preview ready! Click Details to the right of \u0026ldquo;Deploy preview ready\u0026rdquo; to see a preview of your updates. Continue updating your doc and pushing your changes until you\u0026rsquo;re happy with the content. When you\u0026rsquo;re ready for a review, add a comment to the PR, and remove any \u0026ldquo;WIP\u0026rdquo; markers.  Previewing your changes locally If you want to run your own local Hugo server to preview your changes as you work:\n  Install Hugo and any other tools you need. You\u0026rsquo;ll need at least Hugo version 0.45 (we recommend using the most recent available version), and it must be the extended version, which supports SCSS.\n  Fork the Codyze repo repo into your own project, then create a local copy using git clone. Don’t forget to use --recurse-submodules or you won’t pull down some of the code you need to generate a working site.\ngit clone --recurse-submodules --depth 1 https://github.com/google/docsy-example.git   Run hugo server in the site root directory. By default your site will be available at http://localhost:1313/. Now that you\u0026rsquo;re serving your site locally, Hugo will watch for changes to the content and automatically refresh your site.\n  Continue with the usual GitHub workflow to edit files, commit them, push the changes up to your fork, and create a pull request.\n  Creating an issue If you\u0026rsquo;ve found a problem in the docs, but you\u0026rsquo;re not sure how to fix it yourself, please create an issue in the Codyze repo and add the label documentation to it. You can also create an issue about a specific page by clicking the Create Issue button in the top right hand corner of the page.\nContributing to Codyze Opening an issue We welcome any bug reports! Please use the issue tracker only to report bugs or unexpected behavior. If you have general questions about the project or need help in setting it up, please reach out to us directly and do not the issue tracker.\nTo report a bug, make sure to include the following information:\n What have you done? Provide the minimal set of files needed to reproduce the bug. If we cannot reproduce it, it\u0026rsquo;s not a bug. What outcome have you expected, what outcome did you get? Can you provide any hints on what might be the cause of the bug and how you think it should be fixed?  Useful resources  Docsy user guide: All about Docsy, the documentation template we use, including how it manages navigation, look and feel, and multi-language support. Hugo documentation: Comprehensive reference for Hugo. Github Hello World!: A basic introduction to GitHub concepts and workflow.  ","excerpt":"Codyze is open source and an ongoing effort to support developers and auditors in improving the …","ref":"https://www.codyze.io/docs/contributors/","title":"Contributing to Codyze"},{"body":"Security is hard and implementing it correctly is even harder. Luckily, there are well-established and battle-proven libraries available that do the heavy lifting of security functions such as authentication, logging or encryption. But even when using these libraries in application code, developers run the risk of making subtle errors which may undermine the security of their application. This is where Codyze helps. By integrating it into an IDE or CI pipeline, developers can analyse their source code while programming and check if they are using libraries in a correct or in an insecure way.\nHow does it work? In contrast to many other static analysis tools, Codyze directly analyzes the source code and does not require a compiler tool-chain. It can thus even analyse incomplete source code and tolerate small syntax errors.\nCodyze is based on a \u0026ldquo;Code Property Graph\u0026rdquo;, which represents the source code as a graph and adds semantic information to support the analysis. This representation can be used in two ways:\n as a fully automated tool, integrated into your CI or IDE as a database that can be manually explored using a simple query language  Why Codyze? Codyze checks source code for the correct usage of libraries. It is an addition to generic static analysis tools such as Sonarqube, Frama-C, or the Checker Framework and specifically verifies that libraries are used as originally intended by their developers.\nLibrary developers write rules for their library in a simple domain specific language, called MARK.\nDevelopers verify their code against rules of modelled libraries using Codyze - either as an IDE-plugin or as a CI module.\nIntegrators of open source components may want to verify these components using the automated analyis of Codyze or by manually search the code for critical patterns.\n","excerpt":"Security is hard and implementing it correctly is even harder. Luckily, there are well-established …","ref":"https://www.codyze.io/docs/","title":"Documentation"},{"body":"  #td-cover-block-0 { background-image: url(/featured-background_hu744c9eb6bfbbb78fd81068ea1bd69d83_6858932_960x540_fill_q75_catmullrom_top.jpg); } @media only screen and (min-width: 1200px) { #td-cover-block-0 { background-image: url(/featured-background_hu744c9eb6bfbbb78fd81068ea1bd69d83_6858932_1920x1080_fill_q75_catmullrom_top.jpg); } }  Codyze: Static Code Analysis Documentation   Download   Spotting flaws in C/C++, Java, Golang and Python code - automagically!\n\n        Codyze has been funded by the Bundesamt für Sicherheit in der Informationstechnik (BSI). The Code Property Graph project is funded by the Bavarian Ministry of Economic Affairs (StMWi).\n            Download Codyze and get started! Head to the release page  and download Codyze.\nWe offer IDE plugins for Eclipse , Visual Studio  and Visual Studio Code . Moreover, we support LSP  for integration into your favorite IDE or text editor.\n   Codyze in Action! Your browser does not support the video tag.     Get Invovled Visit us on GitHub  to get involved.\n    ","excerpt":"#td-cover-block-0 { background-image: …","ref":"https://www.codyze.io/","title":"Codyze"},{"body":"","excerpt":"","ref":"https://www.codyze.io/index.json","title":""},{"body":"","excerpt":"","ref":"https://www.codyze.io/community/","title":"Community"},{"body":"","excerpt":"","ref":"https://www.codyze.io/search/","title":"Search Results"}]