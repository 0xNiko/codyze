[{"body":"MARK is a simple domain specific language (DSL) that can be written in any text editor. We recommend however using the MARK Eclipse plugin which brings syntax highlighting, auto-completion, and some other benefits that will support you in writing MARK rules.\nInstall the MARK Eclipse Plugin  In Eclipse, click on Help-\u0026gt;Install new software Add the update site: https://update.breakpoint-security.com Install (TODO: Name of product in eclipse update site)  Start writing MARK policies  Create a new project by clicking on New-\u0026gt;Project. The project type does not matter. Create a new file with the extension .mark Start writing entities and rules. You may include all entities and rules in a single MARK file or organize them in multiple files as you with. As long as all MARK files are located in the same folder, Codyze will load entities and rules from all files in that folder.  ","excerpt":"MARK is a simple domain specific language (DSL) that can be written in any text editor. We recommend …","ref":"https://www.codyze.io/docs/mark-authors/installation/","title":"Install MARK IDE"},{"body":"Prerequisites  Java (OpenJDK) 11 or later  Check out, build, and extend Codyze  Fork the Codyze repo on GitHub and clone it, including submodules:\ngit clone --recurse-submodules git://github.com/\u0026lt;YOUR GITHUB\u0026gt;/codyze Create a branch for your contribution. We recommend prefixing the branch name with fix- if you are providing a bug fix or feature- if you plan to add a feature:\ngit checkout -b feature-MY_EPIC_FEATURE Make your changes and make sure that the project builds without errors, passes all tests, and is properly formatted:\n./gradlew clean spotlessApply build publishToMavenLocal installDist\nThe purpose of these gradle tasks is as follows:  clean Removes previous build artifacts spotlessApply Applies source code formatting with the settings in formatter-settings.xml. If the code is not properly formatted the build server will reject it. build Builds the main artifact (the jar file containing Codyze) publishToMavenLocal (optional) publishes the build artifact to your local Maven repository so it is available as a dependency for other projects installDist Create an executable script for Linux, Mac, and Windows in build/install/codyze/bin   When everything works, git commit your changes and git push them to Github, then create a pull request (PR). Make sure to describe want you intend the code to do and refer to any issues your PR might address (using the notation #123) If you\u0026rsquo;re not yet ready for a review, add \u0026ldquo;WIP\u0026rdquo; to the PR name to indicate it\u0026rsquo;s a work in progress. Wait for the automated CI workflow to do some checks. Continue working on your PR by pushing further commits to your branch until you are satisfied When you\u0026rsquo;re ready for a review, add a comment to the PR, and remove any \u0026ldquo;WIP\u0026rdquo; markers.  Code formatting Codyze uses the gradle spotless plugin to format source code. You may import the code style definitions into your favorite IDE to apply it immediately.\nGradle  Simply run ./gradlew spotlessApply  IntelliJ  In IntelliJ, open Settings-\u0026gt;Editor-\u0026gt;Code Style-\u0026gt;Java and click on the cog icon. Choose Import Scheme-\u0026gt;Eclipse XML Profile and select the file formatter-settings.xml in the project\u0026rsquo;s root folder.  Eclipse  In Eclipse, open Window-\u0026gt;Preferences-\u0026gt;Java-\u0026gt;Code Style-\u0026gt;Formatter Click Import and select the file formatter-settings.xml in the project\u0026rsquo;s root folder.  ","excerpt":"Prerequisites  Java (OpenJDK) 11 or later  Check out, build, and extend Codyze  Fork the Codyze repo …","ref":"https://www.codyze.io/docs/contributors/code/","title":"Build the project"},{"body":"Install Analysis Server No matter whether you will use an IDE or the console, you first need to install the analysis server.\nPrerequisites\n Java 11 or higher  Download and Install\n Download the zipped analysis server from the release page Unzip the file Run server.bat -l (Windows) or server.sh -l (Mac, Linux) from the unzipped folder to start the analysis server in LSP mode  Integration in Eclipse Codyze can be installed from the following Eclipse update site: https://update.breakpoint-security.com. It has been tested against Eclipse 2019-04 and later.\n Go to Windows-\u0026gt;Preferences-\u0026gt;Codyze Code Analysis and configure the path to the analysis server binary  If the configuration is correct, .java and .cpp files will be automatically scanned when they are saved. Any errors found by Codyze will be highlighted as problems. If Codyze verifies that an API is correctly used, it will create mark the line with a hint.  Integration in IntelliJ  Download and install the LSP Support plugin. Restart IntelliJ. Goto Settings -\u0026gt; Language Server Protocol -\u0026gt; Server Definitions Add a new server definition of type Executable for extension java and navigate to your local /opt/codyze/codyze-1.0.0/bin/codyze script.  If everything works as intended, you should see a green circle in your IntelliJ status bar, indicating that the connection to the language server was successful.\nIntegration in Visual Studio 2019 The Codyze eclipse can be installed from the Visual Studio 2019 Marketplace\nIf you prefer installing the plugin from the release page, proceed as follows:\n Download the zipped extension from the release page Unzip the file Double-click the VSIX-file to install the extension Launch Visual Studio  On startup, the plugin will ask you for the path to Codyze and to the mark files you want to use. If everythings checks out, the plugin will automatically start an instance of Codyze when a solution is opened. It will then scan .cpp files when opened or saved and highlight potential problems.\nIf you later want to adjust the path to Codyze, the mark files or change the command line arguments used for Codyze, in Visual Studio goto Tools -\u0026gt; Options... -\u0026gt; Codyze Plugin -\u0026gt; Codyze Settings.\n","excerpt":"Install Analysis Server No matter whether you will use an IDE or the console, you first need to …","ref":"https://www.codyze.io/docs/getting-started/installation/","title":"Install Codyze"},{"body":"Codyze is a static analysis tool to support developers in correctly using cryptographic libraries.\nCryptography is hard and implementing it correctly is even harder. Luckily, there are well-established and battle-proven libraries available that do the heavy lifting of efficient and side-channel resilient implementation of cryptographic primitives. But even when using these libraries in application code, developers run the risk of making subtle errors that may undermine the security of their application. This is where Codyze helps. It integrates into the IDE or CI pipeline, analyses source code and tells developers if they are using cryptographic libraries in a correct or in an insecure way.\nHow does it work? In contrast to many other static analysis tools, Codyze directly analyzes the source code and does not require a compiler toolchain. It can thus even analyse incomplete source code and tolerate small syntax errors.\nCodyze is based on a \u0026ldquo;Code Property Graph\u0026rdquo;, which represents the source code as a graph and adds semantic information to support the analysis. This representation can be used in two ways:\n as a fully automated tool, integrated into your CI or IDE as a database that can be manually explored using a simple query language  Why Codyze? Codyze checks source code for the correct usage of libraries. It is an addition to generic static analysis tools such as Sonarqube, Frama-C, or Checkerframework and specifically verifies that libraries are used as originally intended by their developers.\nLibrary developers write rules in a simple domain specific language, called MARK.\nDevelopers using the library verify their code against these rules using Codyze - either as an IDE-plugin or as a CI module.\nIntegrators of open source components may want to verify these components using the automated analyis of Codyze or by manually search the code for critical patterns, using the Crymlin query language.\nWhere should I go next?  MARK Authors: You are author of a cryptographic library? Start here to learn how to write MARK rules for your library. Developers: Learn how to use Codyze to check your application code Contributors: Start here to contribute to this documentation or to the project itself.  ","excerpt":"Codyze is a static analysis tool to support developers in correctly using cryptographic libraries. …","ref":"https://www.codyze.io/docs/overview/","title":"Overview"},{"body":"Command line mode When running in command line interface (CLI) mode, Codyze can be used to automatically check a code base against a set of MARK rules. Run codyze to see the supported command line flags:\nUsage: codyze (-c | -l | -t) [[--typestate=\u0026lt;NFA|WPDS\u0026gt;] [--interproc]] [-hV] [-m=\u0026lt;path\u0026gt;] [-o=\u0026lt;file\u0026gt;] [-s=\u0026lt;path\u0026gt;] [--timeout=\u0026lt;minutes\u0026gt;] Codyze finds security flaws in source code -s, --source=\u0026lt;path\u0026gt; Source file or folder to analyze. -m, --mark=\u0026lt;path\u0026gt; Load MARK policy files from folder -o, --output=\u0026lt;file\u0026gt; Write results to file. Use -- for stdout. --timeout=\u0026lt;minutes\u0026gt; Terminate analysis after timeout Default: 120 -h, --help Show this help message and exit. -V, --version Print version information and exit. Execution mode -c Start in command line mode. -l Start in language server protocol (LSP) mode. -t Start interactive console (Text-based User Interface). Analysis settings --typestate=\u0026lt;NFA|WPDS\u0026gt; Typestate analysis mode NFA: Non-deterministic finite automaton (faster, intraprocedural) WPDS: Weighted pushdown system (slower, interprocedural) --interproc Enables interprocedural data flow analysis (more precise but slower).  -c enters command line mode. It will parse all files given by the -s argument, analyze them against the MARK policies given by -m, and write the findings in JSON format to the file given by -o. If -- is given as the output name, the results will be dumped to stdout.\n","excerpt":"Command line mode When running in command line interface (CLI) mode, Codyze can be used to …","ref":"https://www.codyze.io/docs/getting-started/cli/","title":"Using CLI mode"},{"body":"MARK rules refer to entities - abstract objects that wrap the real object classes of the analyzed programming language (in case of object oriented languages) and group methods with similar semantics in so-called _op_s. A MARK entity defines three parts:\n A name A set of ops (operations) A set of MARK variables  Writing MARK rules for a cryptographic library requires a good understanding of the library API and its class hierarchy. We recommend the following approach to writing MARK entities.\n Model relevant classes as MARK entities Define _op_s and variables (Optionally) blacklist some _op_s  Model relevant classes as MARK entities It is certainly not necessary to model all classes of the software library as MARK entities. Rather, you need to identify those classes which hold cryptographic relevant data or provide cryptographic functions. Although in many cases, several classes of the programming language can be summarized in one abstract MARK entity, it might be easier to directly map classes to entities in the first iteration.\nThe name of an entity can be freely chosen. If it refers to a specific class in the programming language, though, it might make sense to name them accordingly.\nDefine Ops and variables The next step is to define _op_s. An op is a group of semantically equal or similar functions, methods, or constructors, given as fully qualified signatures. Especially overloaded functions with the same name but different parameters are candidates for being grouped in an op. For cryptographic libraries, typical _op_s are:\n instantiate - a group of functions for instantiating a class or creating an object of a class initialize - a group of functions that initialize a cryptographic algorithms, e.g. by setting a key or initialization vector. update - a group of functions that process further data by a cryptographic algorithm finalize- a group of functions that terminate a cryptographic algorithm reset- a group of functions that reset a cryptographic algorithm and make it ready for further processing.  The name of an op can be freely chosen. When specifying fully qualified function or method signatures in an op, parameters are typed and can be unnamed or named. Unnamed parameters are indicated by the name \u0026ldquo;_\u0026rdquo; and do not play any role in the definition of rules. Named parameters refer to MARK variables and can be used when writing rules. We recommend to name only those parameters which are required in rules, as named parameters will increase the memory cost and runtime of the analysis.\nExample: The following op instantiate refers to only a single Java method, called de.example.Crypto.getInstance. Neither the return type, nor modifiers such as public, static, final etc. are given in MARK. The method signature contains one named parameter of type java.lang.String and one unnamed parameter without type restriction. Note that the name of the parameter does not relate to the parameter name in the programming language, but rather to a MARK variable.\n op instantiate { de.example.Crypto.getInstance( algorithm : java.lang.String, // Named typed parameter _ // Unnamed untyped parameter ); }  So, this MARK op would include the following methods of a class de.example.Crypto:\n public static Crypto getInstance(String x, String y) private void getInstance(String x, byte y)  It would however not include a method void getInstance(String x) (wrong number of parameters) or getInstance(byte x, String y) (wrong type of 1st parameter).\nTo make use of named parameters, they must additionally be declared as entity variables using the var keyword:\n entity Crypto { var algorithm; // this makes parameter \"algorithm\" available when writing rules. op instantiate { de.example.Crypto.getInstance( algorithm : java.lang.String, // Named typed parameter _ // Unnamed untyped parameter ); } }  (Optionally) blacklist some _ops_s In some cases, groups of functions or methods should not be used at all by a program. This applies e.g. to deprecated functions or functions that are known to be insecure. MARK provides a shortcut to mark any use of such functions as insecure: the forbidden keyword.\n entity Crypto { op instantiate { de.example.Crypto.getInstance( algorithm : java.lang.String, // Named typed parameter _ // Unnamed untyped parameter ); forbidden de.example.Crypto.getInstanceDeprecated(); // Any use of this function will be flagged } }  Any occurrence of getInstanceDeprecated() in the program will be marked as insecure, without further evaluation of rules. This is not only a shortcut, removing the need to write separate rules, but also a way to cut down analysis time, as Codyze does not need to find instances of the entity, but will rather indicate the error immediately when it sees a usage of the method.\nComplete Example  entity org.bouncycastle.crypto.digests.SHA512Digest isa org.bouncycastle.crypto.Digest { var instance : org.bouncycastle.crypto.digests.SHA512Digest; // Alternative for `this` var encodedState : byte[]; var copy : org.bouncycastle.crypto.digests.SHA512Digest; var inByte : byte; var inByteArray : byte[]; var inByteArrayOff : int; var inByteArraylen : int; var outArray : byte[]; var outArrayOff : int; var resultLen : int; op instantiate { this = org.bouncycastle.crypto.digests.SHA512Digest(); this = org.bouncycastle.crypto.digests.SHA512Digest(encodedState); instance = org.bouncycastle.crypto.digests.SHA512Digest(copy); } op update { org.bouncycastle.crypto.digests.SHA512Digest.update(inByte); org.bouncycastle.crypto.digests.SHA512Digest.update(inByteArray, inByteArrayOff, inByteArrayLen); } op finish { org.bouncycastle.crypto.digests.SHA512Digest.finish(); } op finalize { resultLen = org.bouncycastle.crypto.digests.SHA512Digest.doFinal(outArray, outArrayOff); } op reset { org.bouncycastle.crypto.digests.SHA512Digest.reset(); org.bouncycastle.crypto.digests.SHA512Digest.reset(_); } }   ","excerpt":"MARK rules refer to entities - abstract objects that wrap the real object classes of the analyzed …","ref":"https://www.codyze.io/docs/mark-authors/define-entities/","title":"MARK Entities"},{"body":"","excerpt":"","ref":"https://www.codyze.io/docs/getting-started/","title":"Get Started"},{"body":"Starting in Console Mode When starting Codyze with the -t option, it will start an interactive Python console that you can use to explore your source code projects.\n$ codyze -t ██████╗ ██████╗ ██████╗ ██╗ ██╗███████╗███████╗ ██╔════╝██╔═══██╗██╔══██╗╚██╗ ██╔╝╚══███╔╝██╔════╝ ██║ ██║ ██║██║ ██║ ╚████╔╝ ███╔╝ █████╗ ██║ ██║ ██║██║ ██║ ╚██╔╝ ███╔╝ ██╔══╝ ╚██████╗╚██████╔╝██████╔╝ ██║ ███████╗███████╗ ╚═════╝ ╚═════╝ ╚═════╝ ╚═╝ ╚══════╝╚══════╝ Welcome to Codyze! To get help, enter \u0026#34;help()\u0026#34; \u0026gt;\u0026gt;\u0026gt; The console is a standard python console and offers a few extra commands to load, analyze, and explore source code with Codyze. It supports the following standard keyboard shortcuts:\n   Object Shorthand     CTRL+C or CTRL+D Leaves the console   UP, DOWN Navigate backand forth in command history   CTRL+R Search in command history   ALT+B Go back one word   ALT+F Go forth one word    To run any Python snippet, simply enter it at the command prompt:\n\u0026gt;\u0026gt;\u0026gt; print(\u0026#39;Hello world\u0026#39;) Hello world To interact with Codyze, the console provides three main objects: server, query and graph. Each object has a shorthand notation that is an alias to save a few keystrokes, so instead of server you may simply type s.\n   Object Shorthand     server s   query q   graph g    server The server object controls the Codyze analysis server. Use it to load source code projects, MARK files, and start the analysis.\n   Command Description     s.analyze(path) Starts the analysis for the given folder or source file.   s.show_findings() List all findings, including correct and incorrect uses of cryptography. Make sure to call analyze before. Note that the line numbers displayed by show_findings() start counting at 1, as your editor does.   s.list_rules() List all MARK rules which are currently active.   s.load_rules(path) Load additional MARK rules from the given folder or file. Make sure to load rules before calling analyze    query The query object provides access to the Crymlin query interface. Crymlin is an extension of the Apache Gremlin graph traversal language and comes with various shortcuts for exploring code property graphs. To get a first impression of Crymlin, consider the following snippet:\n\u0026gt;\u0026gt;\u0026gt; q.methods() .name() .toList() [main, toString, myMethod, someOtherMethod] This snippet uses the query object q to get all methods (in all files and all classes) from the graph, retrieves their names (name) and collect them in a list (toList).\n","excerpt":"Starting in Console Mode When starting Codyze with the -t option, it will start an interactive …","ref":"https://www.codyze.io/docs/getting-started/console/","title":"Using the Codyze Console"},{"body":"Once the core functions of a cryptographic library have been modeled as MARK entities, you can start writing rules. MARK rules operate over instances of entities and define conditions which must apply to these instances. A MARK \u0026ldquo;instance\u0026rdquo; may correspond to an actual object in the program, but in the case of non-object oriented languages or static methods, it may simply be an abstract set of function calls and variables.\nBasic rule structure MARK rules are structured as follows:\n rule MyRule { using // instances go here ensure // conditions go here onfail // error message goes here }  Each rule has a name which must be unique across along all MARK files loaded into Codyze. The using keyword starts the declaration of instances of MARK entities and the ensure keyword starts the actual condition. If Codyze finds a violation of the condition in the program, it will issue a finding with the message indicated by the onfail identifier.\nTo illustrate the process of writing MARK rules, let us assume we want to ensure that the MARK entity Crypto from the previous section uses either of the two cryptographic algorithms Algo1 or Algo2 and that the algorithm is initiated with a parameter which is longer than 16 bytes.\n rule ID_2 { using Crypto as c, // instance c of MARK entity Crypto CryptoParameter as cp // instance cp of MARK entity CryptoParameter ensure _is(c.param, cp) // variable c.param == cp \u0026\u0026 _length(cp.rawData) = 16 // byte length of cp.rawData = 16 onfail // todo }  Preconditions Some rules only apply if certain preconditions are fulfiled, i.e. such preconditions will be evaluated before the actual condition. If they fail, the main condition will not be evaluated and the rule will not return any result (i.e. it will neither confirm a valid program nor flag a wrong program). Preconditions follow the same syntax as the main condition, but are declared by the when keyword.\n rule ID_2 { using Crypto as c, // instance c of MARK entity Crypto CryptoParameter as cp // instance cp of MARK entity CryptoParameter when c.algorithm == \"Algo1\" // rule is only relevant for \"Algo1\" ensure _is(c.param, cp) // variable c.param == cp \u0026\u0026 _length(cp.rawData) = 16 // byte length of cp.rawData = 16 onfail // todo }  Built-in Predicates MARK comes with a number of built in functions that can be used as predicates in conditions and preconditions. These built-ins are called when MARK rules are evaluated and operate over their input arguments (typically MARK objects or constants) and the current evaluation context. By convention, built-ins should start with an underscore (_). When a built-in fails, it will return an Error object that always evaluates to not applicable, i.e. neither true nor false.\n_has_value Function: __has_value(a,b)\nExample:\n ensure __has_value(a, b) Returns true if MARK object a may be assigned value b (e.g., a constant).\n_inside_same_function Function: __inside_same_function(a,b)\nExample:\n ensure __inside_same_function(a, b) Returns true if MARK objects a and b reside in the same function.\n_is Function: _is(a,b)\nExample:\n ensure _is(a, b) Returns true if MARK object a is equal to variable b.\n_split Function: _split(String str, String splitter, int position)\nExample: TODO\nBehaves like the Java expression String.split(String splitter)[position]. That is, it splits the string str at all occurrences of splitter and returns the positionth substring. Returns an Error if no such occurrence is found.\n","excerpt":"Once the core functions of a cryptographic library have been modeled as MARK entities, you can start …","ref":"https://www.codyze.io/docs/mark-authors/mark-authors/","title":"MARK Rules"},{"body":"Crymlin is an extension of the graph traversal language Apache Gremlin that comes with additional expressions for exploring code property graphs.\nA graph traversal is an iterator over elements of the graph (nodes, edges, labels, properties) that always starts with a traversal source, then continues with any number of traversal steps and ends with a single terminator step. To understand these concepts, let\u0026rsquo;s consider a simple example:\n\u0026gt;\u0026gt;\u0026gt; q.methods() .name() .toList() [main, toString, myMethod, someOtherMethod] In this example, methods() is a traversal source that starts iterating the graph at all nodes representing a method. name() is a traversal step that retrieves the name property of these nodes and toList() is a terminator that collects all names in a list. Every graph traversal needs a terminator to produce meaningful output. Until the console encounters a terminator, it will treat the graph traversal as an iterator that can be modified by further traversal steps.\nQuery terminators The most used terminators are:\n   Terminator Description     .next() Returns the first element that matches the query or NoSuchElementException if the query result is empty.   .tryNext() Returns the first element that matches the query or an empty Optional if the query result is empty.   .toList() Collects all query results in a list and returns it. Not that for queries returning very large result sets, this terminator will consume more memory and CPU time.   .toSet() Collects all query results in a set (removing duplicates) and returns it. Note that for queries returning very large result sets, this terminator will consume more memory and CPU time.   .count() Returns the number of elements matches by the query.    Traversal Sources Every query must begin with a traversal source which retrieves an initial iterator over nodes from the graph which can then be modified by further traversal steps. The most simple source is V() which includes all nodes of the graph.\n   Traversal Source Description     .byID(int id) Node with the give id. The id of a node can be retrieved by the .id() step.   .calls() Calls to methods or functions (CallExpression)   .calls(String calleeName) Calls to methods or functions matching this name (CallExpression)   .ctor(String type) Constructors of the given fully qualified type (ConstructExpression)   .declarations() All declarations (of fields, variables, records, etc. (any of FieldDeclaration, VariableDeclaration, RecordDeclaration, etc.)   .fields() Declarations of fields (FieldDeclaration)   .field(String fieldName) Declarations of fields with the given name (FieldDeclaration)   .functions() Class methods and functions (FunctionDeclaration)   .methods() Class methods (MethodDeclaration)   .records() Records are classes, enums, structs (RecordDeclaration)   .records(String name) Records such as classes, enums, structs that match the given name (RecordDeclaration)   .translationunits() File names of matching source code (TranslationUnit)   .vars() Declarations of variables (VariableDeclaration)   .V() All nodes in the graph    Traversal Steps Traversal sources and steps are the main operators of Crymlin queries. They determine which nodes and properties are retrieved from the graph. The Crymlin query language accepts all traversal steps supported by Apache Gremlin, plus the following steps which are specific to the exploration of the code property graph.\n   Traversal Step  Description     .argument(int n) Returns the the n-th argument of a function or method call (ArgumentExpression)   .body() Body of a function or method as a node. If the body contains more than one statement, this will typically return a CompoundStatement node   .code() Source code of the selected nodes as a string   .comment() Any inline comment of the current CPG node   .file() Name of the source code file containing the current CPG node   .label() Label of CPG node. The node label is the type of the CPG node (e.g., MethodDeclaration)   .name() Name of the selected nodes as a string   .nextCfg() Returns the next node(s) along the control flow graph (CFG)   .prevCfg() Returns the next node(s) along the control flow graph (CFG)   .nextEog() Next node(s) along the Evaluation Order Graph (EOG)   .prevEog() Previous node(s) along the Evaluation Order Graph (EOG)   .nextDfg() Next node(s) along the Evaluation Order Graph (EOG)   .prevDfg() Previous node(s) along the Evaluation Order Graph (EOG)    ","excerpt":"Crymlin is an extension of the graph traversal language Apache Gremlin that comes with additional …","ref":"https://www.codyze.io/docs/crymlin-query/","title":"Crymlin Query Language"},{"body":"Codyze parses source code and checks it for compliance with predefined policies. These policies are written in a domain-specific language called MARK and describe the correct and expected use of security-critical APIs.\nCodyze comes with a set of MARK policies for the Botan (C++) and Bouncycastle (Java) libraries, but MARK policies can be added anytime and are not necessarily limited to cryptographic libraries.\nMARK policies are simple text files and can be created with any text editor, but we recommend installing the Eclipse plugin which comes with syntax highlighting and code completion for MARK files and can be downloaded here.\nMARK policies are separated into Entities and Rules.\n Entities describe and group API functions at an abstract level and declare MARK variables that refer to function arguments or return values. Rules describe the expected usage of these entities. A violation of a rule will result in a Finding and shown as a warning or error in the developer\u0026rsquo;s IDE.  When modeling a new library, you will typically start by describing its classes or functions as MARK entitites and then write rules.\n","excerpt":"Codyze parses source code and checks it for compliance with predefined policies. These policies are …","ref":"https://www.codyze.io/docs/mark-authors/","title":"Write MARK Policies"},{"body":" Codyze is open source and an ongoing effort to support developers and auditors in improving the quality of security-critical code. We welcome everybody to contribute to this project, be it fixing a typo in the documentation or implementing whole new language support and analysis modules.\nPlease note that parts of this Codyze are backed by research projects. If you plan to make larger contributions, please contact us upfront to align your plans with possibly ongoing projects.\n Contributing to this documentation This documentation lives in the same repository as the code and the idea is that both are always consistent. If you make changes in the code that affect the documentation, please update the documentation in the same pull request.\nTo extend or fix errors in this documentation, proceed as follows:\n Fork the Codyze repo on GitHub. Make your changes and send a pull request (PR). If you\u0026rsquo;re not yet ready for a review, add \u0026ldquo;WIP\u0026rdquo; to the PR name to indicate it\u0026rsquo;s a work in progress. (Don\u0026rsquo;t add the Hugo property \u0026ldquo;draft = true\u0026rdquo; to the page front matter, because that prevents the auto-deployment of the content preview described in the next point.) Wait for the automated PR workflow to do some checks. When it\u0026rsquo;s ready, you should see a comment like this: deploy/netlify — Deploy preview ready! Click Details to the right of \u0026ldquo;Deploy preview ready\u0026rdquo; to see a preview of your updates. Continue updating your doc and pushing your changes until you\u0026rsquo;re happy with the content. When you\u0026rsquo;re ready for a review, add a comment to the PR, and remove any \u0026ldquo;WIP\u0026rdquo; markers.  Previewing your changes locally If you want to run your own local Hugo server to preview your changes as you work:\n  Install Hugo and any other tools you need. You\u0026rsquo;ll need at least Hugo version 0.45 (we recommend using the most recent available version), and it must be the extended version, which supports SCSS.\n  Fork the Codyze repo repo into your own project, then create a local copy using git clone. Don’t forget to use --recurse-submodules or you won’t pull down some of the code you need to generate a working site.\ngit clone --recurse-submodules --depth 1 https://github.com/google/docsy-example.git   Run hugo server in the site root directory. By default your site will be available at http://localhost:1313/. Now that you\u0026rsquo;re serving your site locally, Hugo will watch for changes to the content and automatically refresh your site.\n  Continue with the usual GitHub workflow to edit files, commit them, push the changes up to your fork, and create a pull request.\n  Creating an issue If you\u0026rsquo;ve found a problem in the docs, but you\u0026rsquo;re not sure how to fix it yourself, please create an issue in the Codyze repo and add the label documentation to it. You can also create an issue about a specific page by clicking the Create Issue button in the top right hand corner of the page.\nContributing to Codyze Opening an issue We welcome any bug reports! Please use the issue tracker only to report bugs or unexpected behavior. If you have general questions about the project or need help in setting it up, please reach out to us directly and do not the issue tracker.\nTo report a bug, make sure to include the following information:\n What have you done? Provide the minimal set of files needed to reproduce the bug. If we cannot reproduce it, it\u0026rsquo;s not a bug. What outcome have you expected, what outcome did you get? Can you provide any hints on what might be the cause of the bug and how you think it should be fixed?  Useful resources  Docsy user guide: All about Docsy, the documentation template we use, including how it manages navigation, look and feel, and multi-language support. Hugo documentation: Comprehensive reference for Hugo. Github Hello World!: A basic introduction to GitHub concepts and workflow.  ","excerpt":"Codyze is open source and an ongoing effort to support developers and auditors in improving the …","ref":"https://www.codyze.io/docs/contributors/","title":"Contributing to Codyze"},{"body":"Cryptography is hard and implementing it correctly is even harder. Luckily, there are well-established and battle-proven libraries available that do the heavy lifting of efficient and side-channel resilient implementation of cryptographic primitives. But even when using these libraries in application code, developers run the risk of making subtle errors that may undermine the security of their application. This is where Codyze helps. It integrates into the IDE or CI pipeline, analyses source code and tells developers if they are using cryptographic libraries in a correct or in an insecure way.\nHow does it work? In contrast to many other static analysis tools, Codyze directly analyzes the source code and does not require a compiler toolchain. It can thus even analyse incomplete source code and tolerate small syntax errors.\nCodyze is based on a \u0026ldquo;Code Property Graph\u0026rdquo;, which represents the source code as a graph and adds semantic information to support the analysis. This representation can be used in two ways:\n as a fully automated tool, integrated into your CI or IDE as a database that can be manually explored using a simple query language  Why Codyze? Codyze checks source code for the correct usage of libraries. It is an addition to generic static analysis tools such as Sonarqube, Frama-C, or Checkerframework and specifically verifies that libraries are used as originally intended by their developers.\nLibrary developers write rules in a simple domain specific language, called MARK.\nDevelopers using the library verify their code against these rules using Codyze - either as an IDE-plugin or as a CI module.\nIntegrators of open source components may want to verify these components using the automated analyis of Codyze or by manually search the code for critical patterns, using the Crymlin query language.\n","excerpt":"Cryptography is hard and implementing it correctly is even harder. Luckily, there are …","ref":"https://www.codyze.io/docs/","title":"Documentation"},{"body":"","excerpt":"","ref":"https://www.codyze.io/index.json","title":""},{"body":"  #td-cover-block-0 { background-image: url(/featured-background_hu2f88d737ab3a9a131efa9117f08fffd8_430841_960x540_fill_q75_catmullrom_top.jpg); } @media only screen and (min-width: 1200px) { #td-cover-block-0 { background-image: url(/featured-background_hu2f88d737ab3a9a131efa9117f08fffd8_430841_1920x1080_fill_q75_catmullrom_top.jpg); } }  Codyze: Static Code Analysis Documentation   Download   Spotting flaws in Java and C++ code - automagically!\n\n        Codyze has been funded by the Bundesamt für Sicherheit in der Informationstechnik (BSI). The Code Property Graph project is funded by the Bavarian Ministry of Economic Affairs (StMWi).\n            Download Codyze and get started! Head to the release page and download the plugin for the IDE of your choice.\nWe support Eclipse, IntelliJ, VSCode, and Visual Studio Code on Windows, Mac, and Linux.\n   Contributions welcome! We do a Pull Request contributions workflow on GitHub. New users are always welcome!\nRead more …\n   Follow us on Twitter! For announcement of latest features etc.\nRead more …\n    ","excerpt":"#td-cover-block-0 { background-image: …","ref":"https://www.codyze.io/","title":"Codyze"},{"body":"","excerpt":"","ref":"https://www.codyze.io/community/","title":"Community"},{"body":"","excerpt":"","ref":"https://www.codyze.io/search/","title":"Search Results"}]